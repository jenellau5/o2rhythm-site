<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tension Drop — O₂ Rhythm</title>
    <link rel="stylesheet" href="../assets/style.css" />
    <style>
        :root {
            --ring: #ffffff;
        }

        /* Big prompt text */
        .prompt {
            margin-top: 14px;
            font-size: 1.05rem;
            font-weight: 900;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .promptSub {
            margin-top: 6px;
            color: rgba(255, 255, 255, .70);
            font-size: .9rem;
            line-height: 1.4;
        }
    </style>
</head>

<body>
    <main class="wrap">
        <section class="card protocol" data-agency="mytrex" data-environment="desk" data-protocol-id="tension_drop">

            <div class="brand">O₂ RHYTHM</div>
            <h1>TENSION DROP</h1>
            <p class="sub">30 sec • Release + re-stack</p>

            <div class="ringbox">
                <svg class="progressRing" viewBox="0 0 220 220" aria-hidden="true">
                    <circle class="progress-bg" cx="110" cy="110" r="100"></circle>
                    <circle class="progress" cx="110" cy="110" r="100"></circle>
                </svg>

                <div id="pacer" class="pacer">
                    <div class="center">
                        <button id="startBtn" class="start" type="button">START</button>
                        <div id="timer" class="timer">0:30</div>

                        <div id="phaseLabel" class="phaseLabel">READY</div>
                        <div id="count" class="count"></div>
                        <div id="dots" class="phaseDots"></div>
                    </div>
                </div>
            </div>

            <div class="prompt" id="prompt">READY</div>
            <div class="promptSub" id="promptSub">Press START when you can.</div>

            <div class="toggleRow">
                <button id="soundToggle" class="toggle" type="button">SOUND: OFF</button>
            </div>

            <div class="navrow">
                <a class="pill" href="desk.html">Back</a>
                <a class="pill" href="library.html">Library</a>
            </div>

            <div class="feedback">
                <a class="feedback-link" href="feedback.html">Pilot feedback (30 seconds)</a>
            </div>

        </section>
    </main>

    <script>
        // -------------------------------
        // TENSION DROP (30 sec) — guided
        // -------------------------------

        const page = document.querySelector(".protocol");
        const startBtn = document.getElementById("startBtn");
        const timerEl = document.getElementById("timer");
        const phaseLabelEl = document.getElementById("phaseLabel");
        const promptEl = document.getElementById("prompt");
        const promptSubEl = document.getElementById("promptSub");
        const progressCircle = document.querySelector(".progress");

        const soundToggleBtn = document.getElementById("soundToggle");

        const total = 30;
        let timeLeft = total;
        let running = false;
        let interval = null;

        // Analytics identity (optional)
        const agency = page?.dataset.agency || "unknown";
        const environment = page?.dataset.environment || "unknown";
        const protocolId = page?.dataset.protocolId || "unknown";

        function ga(eventName, params = {}) {
            if (typeof window.gtag !== "function") return;
            window.gtag("event", eventName, {
                agency,
                environment,
                protocol: protocolId,
                page_path: location.pathname,
                ...params
            });
        }

        // Ring math
        const r = 100;
        const circumference = 2 * Math.PI * r;
        progressCircle.style.strokeDasharray = String(circumference);
        progressCircle.style.strokeDashoffset = String(circumference);

        function fmt(s) {
            const m = Math.floor(s / 60);
            const ss = String(s % 60).padStart(2, "0");
            return `${m}:${ss}`;
        }

        function setOverallProgress(secondsRemaining) {
            const elapsed = total - secondsRemaining;
            const ratio = Math.min(1, Math.max(0, elapsed / total));
            const offset = circumference - ratio * circumference;
            progressCircle.style.strokeDashoffset = String(offset);
        }

        // SOUND ON/OFF
        const SS_SOUND = "o2_sound_enabled";
        let soundEnabled = sessionStorage.getItem(SS_SOUND) === "1";
        let audioCtx = null;

        function ensureAudioContext() {
            if (audioCtx) return;
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            audioCtx = new Ctx();
        }

        function setSoundUI() {
            soundToggleBtn.textContent = soundEnabled ? "SOUND: ON" : "SOUND: OFF";
            soundToggleBtn.setAttribute("aria-pressed", soundEnabled ? "true" : "false");
        }

        function beep(freq = 440, durationSec = 0.12) {
            if (!soundEnabled) return;
            ensureAudioContext();
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = "sine";
            osc.frequency.value = freq;

            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.exponentialRampToValueAtTime(0.04, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start(now);
            osc.stop(now + durationSec);
        }

        soundToggleBtn.addEventListener("click", () => {
            soundEnabled = !soundEnabled;
            sessionStorage.setItem(SS_SOUND, soundEnabled ? "1" : "0");
            if (soundEnabled) ensureAudioContext();
            setSoundUI();
            ga("protocol_toggle", { toggle: "sound", enabled: soundEnabled ? 1 : 0 });
        });

        // Prompt schedule (simple, obvious)
        const schedule = [
            { t: 30, label: "FEET DOWN", sub: "Press feet into the floor.", tone: 440 },
            { t: 24, label: "SQUEEZE", sub: "Make fists. 3 seconds.", tone: 520 },
            { t: 21, label: "RELEASE", sub: "Let go. Drop shoulders.", tone: 330 },
            { t: 16, label: "STACK", sub: "Back to chair. Sit tall.", tone: 440 },
            { t: 10, label: "RESET", sub: "Chin level. Jaw unclenched.", tone: 330 },
            { t: 5, label: "READY", sub: "Slow blink. Continue.", tone: 440 }
        ];

        let currentStepIdx = -1;

        function applyStepForTime(secondsLeft) {
            // Find first schedule item where secondsLeft >= t
            const idx = schedule.findIndex(s => secondsLeft >= s.t);
            if (idx === -1) return;

            if (idx !== currentStepIdx) {
                currentStepIdx = idx;
                const step = schedule[idx];
                phaseLabelEl.textContent = step.label;
                promptEl.textContent = step.label;
                promptSubEl.textContent = step.sub;
                beep(step.tone, 0.12);
            }
        }

        function resetUI() {
            running = false;
            timeLeft = total;
            timerEl.textContent = fmt(total);
            setOverallProgress(total);
            phaseLabelEl.textContent = "READY";
            promptEl.textContent = "READY";
            promptSubEl.textContent = "Press START when you can.";
            startBtn.disabled = false;
            startBtn.textContent = "START";
            currentStepIdx = -1;
        }

        function endSession() {
            ga("protocol_complete", { total_seconds: total });

            clearInterval(interval);
            interval = null;
            running = false;

            startBtn.textContent = "DONE";
            phaseLabelEl.textContent = "DONE";
            promptEl.textContent = "DONE";
            promptSubEl.textContent = "Baseline restored. Continue.";

            setTimeout(resetUI, 900);
        }

        // Bail-out tracking
        window.addEventListener("visibilitychange", () => {
            if (!running) return;
            if (document.visibilityState === "hidden") {
                ga("protocol_abandon", { seconds_remaining: timeLeft });
            }
        });

        function start() {
            if (running) return;
            running = true;
            startBtn.disabled = true;
            startBtn.textContent = "RUNNING";

            ga("protocol_start", { total_seconds: total });

            timeLeft = total;
            timerEl.textContent = fmt(timeLeft);
            setOverallProgress(timeLeft);

            applyStepForTime(timeLeft);

            interval = setInterval(() => {
                timeLeft -= 1;
                timerEl.textContent = fmt(Math.max(0, timeLeft));
                setOverallProgress(Math.max(0, timeLeft));

                applyStepForTime(timeLeft);

                if (timeLeft <= 0) endSession();
            }, 1000);
        }

        startBtn.addEventListener("click", start);

        // Init
        setSoundUI();
        resetUI();
    </script>
</body>

</html>